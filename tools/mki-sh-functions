#!/bin/sh -efu

if [ -z "${__included_mki_sh_functions:-}" ]; then
__included_mki_sh_functions=1

. shell-error
. shell-args

verbose="${VERBOSE:+-v}"
quiet="${QUIET:+-q}"

workdirname=${WORKDIRNAME:?Work directory name required}
outdirname=${OUTDIRNAME:?Out directory name required}
#cachedirname=${CACHEDIRNAME:?Cache directory name required}

bindir="${TOOLSDIR:?Helper directory required}"
bindir="$(opt_check_dir 'TOOLSDIR' "$bindir")"

curdir="${CURDIR:?Current directory required}"
curdir="$(opt_check_dir 'CURDIR' "$curdir")"

cachedir="${CACHEDIR:?cache required}"
outdir="${OUTDIR:?Output directory required}"
dir="${WORKDIR:?Work directory required}"

if [ -z "${include_without_workdir_check-}" ]; then
	cachedir="$(opt_check_dir 'CACHEDIR' "$cachedir")"
	outdir="$(opt_check_dir 'OUTDIR' "$outdir")"
	dir="$(opt_check_dir 'WORKDIR' "$dir")"
fi

chroot="$dir/chroot"

subdir="$chroot/$WORKDIRNAME"
subchroot="$subdir/chroot"

makefile="${MYMAKEFILE:?makefile required}"
makefile="$(opt_check_read 'MYMAKEFILE' "$makefile")"

[ -s "$makefile" ] ||
	fatal "$makefile: Makefile is empty"

export PATH="$bindir:$PATH"

cp_args=
get_copy_args() {
	[ "$#" -ge 2 ] ||
		fatal "get_copy_args(): more arguments required"

	cp_args=
	[ $(find "$@" -printf '%D\n' 2>/dev/null |sort -u |wc -l) -eq 1 ] ||
		return 0
	cp_args='-l'
}

mki_exec_once() {
	local rc=0 prog
	prog="$1"; shift

	mki-exec "$prog" || rc=$?
	rm -f -- "$prog"

	[ "$rc" -eq 0 ] ||
		exit $rc
}

mki_list_pkgs() {
	local r
	for r in "$@"; do
		if [ -f "$r" ]; then
			grep -h '^[[:space:]]*[^#]' "$r" |
				tr ' ' '\n'
		else
			printf '%s\n' "$r"
		fi
	done
}

fi
