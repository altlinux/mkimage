#!/bin/ash -efu
#
# mki-copy-efiboot
#
# This file is part of mkimage
# Copyright (C) 2007-2009  Alexey Gladkov <gladkov.alexey@gmail.com>
# Copyright (C) 2012       Michael Shigorin <mike@altlinux.org>
#
# This file is covered by the GNU General Public License,
# which should be included with mkimage as the file COPYING.
#

. "${0%/*}"/mki-sh-functions

verbose "has started executing."

pkgs="${PACKAGES_REQUIRED_COPY_EFIBOOT:-}"

[ -d "$chroot" ] ||
	fatal "$dir: does not look like a hasher work directory."

# should be a package name
[ -n "${EFI_BOOTLOADER:-}" ] ||
	fatal "EFI_BOOTLOADER is empty."

pkgs="$pkgs $EFI_BOOTLOADER"

# should be a package name
[ -z "${EFI_SHELL:-}" ] ||
	pkgs="$pkgs $EFI_SHELL"

[ -z "${EFI_CERT:-}" ] ||
	pkgs="$pkgs alt-uefi-keys shim-signed $EFI_BOOTLOADER-signed"

case "${EFI_BOOTLOADER:-}" in
refind)	# won't boot unsigned kernels in SB mode
	pkgs="$pkgs elilo${EFI_CERT:+-signed}"
	;;
esac

mki-install $pkgs ||
	fatal "failed to install packages: $pkgs."

make_exec "$chroot/.host/efiboot.sh" <<EOF
#!/bin/sh -efu${verbose:+x}

cd /.image

fatal() { echo $*; exit 1; }

stage2=
for i in altinst live rescue; do
	if [ -f "\$i" ]; then
		stage2="\$i"
		break
	fi
done
[ -n "\${stage2:-}" ] ||
	fatal "no stage2 image found."

efi=EFI
boot=\$efi/BOOT
tools=\$efi/tools
shell=shellx64.efi
mkdir $verbose -p -- \$boot

# nexthop name is hardwired into shim-0.2
if [ -n "${EFI_CERT:-}" ]; then
	shim_path=\$boot/BOOTX64.EFI
	bin_path=\$boot/GRUBX64.EFI
	bin_suffix=-signed
else
	shim_path=
	bin_path=\$boot/BOOTX64.EFI
	bin_suffix=
fi

stage2_size="\$[ \$(stat -c%s \$stage2) / 1024 + 1 ]"
bootparams="fastboot live splash lowmem showopts automatic=method:cdrom"
bootparams="\$bootparams ramdisk_size=\$stage2_size stagename=\$stage2"

efi_bindir=/usr/lib64/efi

copy_shell() {
	dest="\$efi/\$shell"
	src="\$efi_bindir/shell${EFI_CERT:+-signed}.efi"
	[ ! -f "\$src" ] ||
		cp $verbose -pLf "\$src" "\$dest"
}

copy_cert() {
	[ -n "${EFI_CERT:-}" ] ||
		return 0

	local keyfile="/etc/pki/uefi/${EFI_CERT:-}.cer"
	[ -s "\$keyfile" ] ||
		fatal "invalid \$keyfile"

	cp $verbose -pLft EFI/ -- "\$keyfile"
}

copy_shim() {
	[ -n "\${shim_path:-}" ] ||
		return 0
	copy_cert
	cp $verbose -pLf \$efi_bindir/shim.efi \$shim_path
	cp $verbose -pLf \$efi_bindir/MokManager.efi \$boot
}

copy_kernel() {
	cp $verbose -pLft \$boot -- syslinux/alt0/{vmlinuz,full.cz}
}

copy_elilo() {
	copy_kernel
	cp $verbose -pLf \$efi_bindir/elilo\$bin_suffix.efi \${1:-\$bin_path}
	cat > \$boot/elilo.conf <<- ELILO_EOF
	default="linux"
	image="vmlinuz"
	  label="linux"
	  read-only
	  initrd=full.cz
	  append="\$bootparams"
	ELILO_EOF
}

# refind is currently signed by default
refind_aux=\$efi/refind
refind_boot=\$refind_aux/refind_x64.efi

copy_refind_to() {
	mkdir -p -- "\$2"
	cp $verbose -pLf \$efi_bindir/refind_x64.efi "\$1"
	cp $verbose -aLf \$efi_bindir/drivers_x64/ "\$2"
	cp $verbose -aLf /usr/share/refind/icons/ "\$2"
}

copy_refind() {
	copy_kernel	# seems to be unavoidable
	copy_refind_to \$bin_path \$boot
	copy_refind_to \$refind_boot \$refind_aux
	copy_elilo \$boot/ELILO.EFI

	cat > \$boot/refind.conf <<- REFIND_EOF
	timeout 20
	scanfor manual

	# ELILO used as a SB trampoline for unsigned kernels
	menuentry "ALT Linux" {
	  icon \$boot/icons/os_altlinux.icns
	  loader \$boot/ELILO.EFI
	  # NB: -v seems critical, otherwise we hit this:
	  #     gzip_x86_64: invalid exec_header
	  options "-v -i full.cz vmlinuz \$bootparams"
	}

	menuentry "others" {
	  icon \$boot/icons/os_unknown.icns
	  loader \$refind_boot
	}
	REFIND_EOF
}

[ -z "${EFI_CERT:-}" ] ||
	copy_shim

case "$EFI_BOOTLOADER" in
elilo)
	copy_elilo;;
refind)
	copy_refind;;
*)
	fatal "Unable to handle '$EFI_BOOTLOADER'.";;
esac

copy_shell

imgsize="\$[ \$(du -sB32k \$efi | cut -f1) + 4 ]"
img=.efiboot.img

dd if=/dev/zero of=\$img bs=32k count="\$imgsize"
mkfs.vfat $verbose -n "El Torito" \$img

# put EFI shell into the FAT image's root (for firmware)...
if [ -f \$efi/\$shell ]; then
	mv $verbose \$efi/\$shell .
	mcopy $verbose \$shell -i \$img ::
fi

mcopy $verbose -i \$img -s \$efi ::

# ...and finally into its ISO9660 location for refind
if [ -f \$shell ]; then
	mkdir $verbose -p \$tools
	mv $verbose \$shell \$tools
fi

mv \$img \$efi/
EOF

rc=0
mki-run "/.host/efiboot.sh" || rc=$?
rm -f -- "$chroot/.host/efiboot.sh"
find "$chroot/.in" -mindepth 1 -maxdepth 1 -exec rm -rf -- '{}' '+'
exit $rc
