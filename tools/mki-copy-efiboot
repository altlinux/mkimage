#!/bin/ash -efu
#
# mki-copy-efiboot
#
# This file is part of mkimage
# Copyright (C) 2007-2009  Alexey Gladkov <gladkov.alexey@gmail.com>
# Copyright (C) 2012       Michael Shigorin <mike@altlinux.org>
#
# This file is covered by the GNU General Public License,
# which should be included with mkimage as the file COPYING.
#

. "${0%/*}"/mki-sh-functions

verbose "has started executing."

pkgs="${PACKAGES_REQUIRED_COPY_EFIBOOT:-}"

[ -d "$chroot" ] ||
	fatal "$dir: does not look like a hasher work directory."

# should be a package name
[ -n "${EFI_BOOTLOADER:-}" ] ||
	fatal "EFI_BOOTLOADER is empty."

pkgs="$pkgs $EFI_BOOTLOADER"

# should be a package name
[ -z "${EFI_SHELL:-}" ] ||
	pkgs="$pkgs $EFI_SHELL"

[ -z "${EFI_CERT:-}" ] ||
	pkgs="$pkgs alt-uefi-keys shim-signed"

case "${EFI_BOOTLOADER:-}" in
refind)	# won't boot unsigned kernels in SB mode
	pkgs="$pkgs elilo"
	;;
esac

mki-install $pkgs ||
	fatal "failed to install packages: $pkgs."

make_exec "$chroot/.host/efiboot.sh" <<EOF
#!/bin/sh -efu${verbose:+x}

cd /.image

fatal() { echo $*; exit 1; }

stage2=
for i in altinst live rescue; do
	if [ -f "\$i" ]; then
		stage2="\$stage2 \$i"
		break
	fi
done
[ -n "\${stage2:-}" ] ||
	fatal "no stage2 image found."

efi=EFI
boot=\$efi/BOOT
cert=\$efi/enroll
tools=\$efi/tools
shell=shellx64.efi
mkdir $verbose -p -- \$boot

# nexthop name is hardwired into shim-0.2
if [ -n "${EFI_CERT:-}" ]; then
	shim_path=\$boot/bootx64.efi
	bin_path=\$boot/grubx64.efi
else
	shim_path=
	bin_path=\$boot/bootx64.efi
fi

bootparams() {
	[ -s "\$1" ] || return 0
	stage2_size="\$[ \$(stat -c%s \$1) / 1024 + 1 ]"
	echo "ramdisk_size=\$stage2_size stagename=\$1"
}

efi_bindir=/usr/lib64/efi

copy_shell() {
	dest="\$efi/\$shell"
	src="\$efi_bindir/shell.efi"
	[ ! -f "\$src" ] ||
		cp $verbose -pLf "\$src" "\$dest"
}

copy_cert() {
	[ -n "${EFI_CERT:-}" ] ||
		return 0

	local keyfile="/etc/pki/uefi/${EFI_CERT:-}.cer"
	[ -s "\$keyfile" ] ||
		fatal "invalid \$keyfile"

	mkdir $verbose -p \$cert
	cp $verbose -pLft \$cert -- "\$keyfile"
}

copy_shim() {
	[ -n "\${shim_path:-}" ] ||
		return 0
	copy_cert
	cp $verbose -pLf \$efi_bindir/shim.efi \$shim_path
	cp $verbose -pLf \$efi_bindir/MokManager.efi \$boot
}

copy_kernel() {
	cp $verbose -pLft \$boot -- syslinux/alt0/{vmlinuz,full.cz}
}

copy_elilo() {
	copy_kernel
	cp $verbose -pLf \$efi_bindir/elilo.efi \${1:-\$bin_path}
	cat > \$boot/elilo.conf <<- ELILO_EOF
	# common bits (elilo complains about missing configuration)
	append="fastboot live splash lowmem showopts automatic=method:cdrom"
	read-only
	image="vmlinuz"
	  label="linux"
	ELILO_EOF
}

refind_aux=\$efi/refind
refind_boot=\$refind_aux/refind_x64.efi

copy_refind_to() {
	mkdir -p -- "\$2"
	touch "\$2"/refind.conf
	cp $verbose -pLf \$efi_bindir/refind_x64.efi "\$1"
	cp $verbose -aLf \$efi_bindir/drivers_x64/ "\$2"
	cp $verbose -aLf /usr/share/refind/icons/ "\$2"
}

add_langs() {
	cat <<- REFIND_EOF
	  submenuentry "English" {
	    add_options "lang=en_US"
	  }
	  submenuentry "Kazakh" {
	    add_options "lang=kk_KZ"
	  }
	  submenuentry "Russian" {
	    add_options "lang=ru_RU"
	  }
	  submenuentry "Ukrainian" {
	    add_options "lang=uk_UA"
	  }
	REFIND_EOF
}

add_stage2() {
	for root in \$stage2; do
		case "\$root" in
		altinst) label="Installation";;
		live) label="Live";;
		rescue) label="Rescue";;
		*) label="\$root";;
		esac

		icon="\$boot/icons/altlinux/\$root.icns"
		[ -s "\$icon" ] || icon="\$boot/icons/os_altlinux.icns"

		cat <<- REFIND_EOF

		# ELILO used as SB trampoline for unsigned kernels
		menuentry "ALT Linux \$label" {
		  icon \$icon
		  loader \$boot/elilo.efi
		  # NB: -v seems critical, otherwise we hit this:
		  #     gzip_x86_64: invalid exec_header
		  options "-v -i full.cz vmlinuz \`bootparams \$root\`"
		REFIND_EOF
		add_langs
		echo "}"
	done
}

copy_refind() {
	copy_kernel	# seems to be unavoidable
	copy_refind_to \$bin_path \$boot
	copy_refind_to \$refind_boot \$refind_aux
	copy_elilo \$boot/elilo.efi

	cat > \$boot/refind.conf <<- REFIND_EOF
	timeout 20
	scanfor manual
	REFIND_EOF

	add_stage2 >> \$boot/refind.conf

	cat >> \$boot/refind.conf <<- REFIND_EOF

	menuentry "others" {
	  icon \$boot/icons/os_unknown.icns
	  loader \$refind_boot
	}
	REFIND_EOF
}

[ -z "${EFI_CERT:-}" ] ||
	copy_shim

case "$EFI_BOOTLOADER" in
elilo)
	copy_elilo;;
refind)
	copy_refind;;
*)
	fatal "Unable to handle '$EFI_BOOTLOADER'.";;
esac

copy_shell

imgsize="\$[ \$(du -sB32k \$efi | cut -f1) + 4 ]"
img=.efiboot.img

dd if=/dev/zero of=\$img bs=32k count="\$imgsize"
mkfs.vfat $verbose -n "El Torito" \$img

# put EFI shell into the FAT image's root (for firmware)...
if [ -f \$efi/\$shell ]; then
	mv $verbose \$efi/\$shell .
	mcopy $verbose \$shell -i \$img ::
fi

mcopy $verbose -i \$img -s \$efi ::

# ...and finally into its ISO9660 location for refind
if [ -f \$shell ]; then
	mkdir $verbose -p \$tools
	mv $verbose \$shell \$tools
fi

mv \$img \$efi/
EOF

rc=0
mki-run "/.host/efiboot.sh" || rc=$?
rm -f -- "$chroot/.host/efiboot.sh"
find "$chroot/.in" -mindepth 1 -maxdepth 1 -exec rm -rf -- '{}' '+'
exit $rc
